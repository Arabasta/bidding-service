package repo

import (
	"context"
	"database/sql"
	"errors"
	"kei-services/internal/bidding/application"
	"kei-services/internal/bidding/domain"
	"kei-services/internal/bidding/infrastructure/db/tx"
	"kei-services/sqlc"

	"go.uber.org/zap"
)

var _ application.IBidRepository = (*BidRepo)(nil)

type BidRepo struct {
	DB  *sql.DB
	Q   *sqlc.Queries // generated by sqlc
	Log *zap.Logger
}

func NewBidRepo(db *sql.DB, log *zap.Logger) *BidRepo {
	return &BidRepo{
		DB:  db,
		Q:   sqlc.New(db),
		Log: log,
	}
}

// todo: add logigng

// Insert returns DB assigned id and seq (used as authoritative version for validation)
func (r *BidRepo) Insert(ctx context.Context, b *domain.Bid) (string, int64, error) {
	q := r.Q
	if t, ok := tx.FromCtx(ctx); ok {
		q = r.Q.WithTx(t)
	}

	row, err := q.InsertBid(ctx, sqlc.InsertBidParams{
		AuctionID: b.AuctionID,
		BidderID:  b.BidderID,
		Amount:    b.Amount,
		At:        b.At.UTC(),
	})
	if err != nil {
		return "", 0, err
	}
	return row.ID, row.Seq, nil
}

func (r *BidRepo) LatestForUpdate(ctx context.Context, auctionID string) (*application.LatestBid, error) {
	q := r.Q
	if t, ok := tx.FromCtx(ctx); ok {
		q = r.Q.WithTx(t)
	}

	res, err := q.LatestForUpdate(ctx, auctionID)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, nil // no bids yet for this auction
		}
		return nil, err
	}

	return &application.LatestBid{
		ID:     res.ID,
		Amount: res.Amount,
		Seq:    res.Seq,
		At:     res.At,
	}, nil
}
